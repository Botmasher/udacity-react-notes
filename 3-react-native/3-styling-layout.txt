/*	Lesson 3: Styling and Layout
		
	1. Introduction
 */



/* 2. CSS in JS
	- React separates concerns at a component level, NOT a technology level
	- What are the two things a component's for?
		1) state - component state
		2) presentation - JSX
	- Presentation is more than just markup, it's also STYLES!
	- React Native default pattern and a common pattern: just use JS
 */

// example of applying styles inline to component through React JSX
function Avatar ({ src }) {
  return (
    <View>
      <Image
        style={{borderRadius: 5, margin: 10, width: 48, height: 48}}
        source={{uri: 'https://exmpl.com/happy_glasses-300.png'}}
      />
    </View>
  );
}

// Problems c these JS objects passed to style
	// - clearly above things can get messy fast (like c a big obj)
	// - so you might DRY your code and store the obj separately
const styles = {
  image: {
    borderRadius: 5,
    margin: 10,
    width: 48,
    height: 48
  }
};

function Avatar ({ src }) {
  return (
    <View>
      <Image
        style={styles.image}
        source={{uri: 'https://exmpl.com/happy_glasses-300.png'}}
      />
    </View>
  );
}

// BUT React Native's StyleSheet API goes even further
 /* Benefits:
 		- define multiple styles in one place
		- move styles away from render function
		- named styles add meaning to low-level components in render function
		- can refer to style object id instead of creating a new stylesheet every time
		- send style only once through the bridge
			- subsequent uses are going to refer to an id
		- compile-time validation of your style objects c errors in the console instead of at runtime
 	*/
import React from 'react';
import { StyleSheet, Text, View } from 'react-native';

export default class TextExample extends React.Component {
  render() {
    return (
      <View>
        <Text style={styles.greenLarge}>This is large green text!</Text>
        <Text style={styles.red}>This is smaller red text!</Text>
      </View>
    );
  }
}

const styles = StyleSheet.create({
  greenLarge: {
    color: 'green',
    fontWeight: 'bold',
    fontSize: 40
  },
  red: {
    color: 'red',
    padding: 30
  },
});

// additional styles can be added as array through styles prop
	// - inherits styles so any last styles will take precedence
<Text style={[styles.red, styles.greenLarge]}>Red text but no wait then actually greenLarge text.</Text>

// libraries include Glamorous and Styled Components, both seeing styles as a primary concern of the component





/* 3. Flexbox Guide
  - whenever approaching new tech, instructor asks, "why does this exist?"
  - Flexbox aims to allow dynamic layouts
    - styling elements even when the size is unknown or changing
    - to accomplish this it moves concern from children to immediate parent
    - e.g. instead of float left each child, tell parent that immed children in row and have space btwn
  - Flexible vs Box Model
    - no use of float
    - flexible across screens and devices

  - most important concept is AXES
    - main axis (default vert)
    - cross axis (default horiz)
    - all else is about deciding how to position, scale, center, wrap elements along those two axes

  - flexDirection
    - by default every element has flexDirection: column  
    - can change to flexDirection: row
    - row switches the axes to main horiz and cross vert

  - Justify Content
    - how children align themselves to a component starting along the Main axis
      - justifyContent: flex-start
      - justifyContent: center
      - justifyContent: flex-end
      - justifyContent: space-around
        - puts even vert space btwn each element but aligns top and bottom elements flush
      - justifyContent: space-between
        - puts even vert space around each element including above/below top/bottom elements
 */

// but what if we flipped axes?
container: {
  flex: 1,
  flexDirection: 'row',
  justifyContent: 'space-around',
}
  // now justified along horiz Main axis c space around each element incl L/R of first/last element!

/* 
  Align Items: the Cross Axis
  - alignItems does NOT have the same values as justifyContent
  - you use different values to order how children align along cross axis
    - flex-start  puts children horizontally left (top if you flip flex-direction: row)
    - center      puts children horizontally centered (vertically centered if you flip flex-direction: row)
    - flex-end    puts children horizontally right (bottom if you flip flex-direction: row)
    - stretch     takes up whole row (column if you flip flex-direction: row)

  - note that FlexBox for Native does NOT do percentages!
  - BUT everything you can do c rel percents on web you can still do here
  - flex: 1 will behave like flex-grow does on web (if you're familiar)
 */

// Flex property - here assign one sibling to 2 so that middle one's twice as large as siblings
// End up with:     BOX | B O X | BOX
class FlexboxExamples extends Component {
  render() {
    return (
      <View style={styles.container}>
        <View style={[styles.box, {flex: 1}]}/>
        <View style={[styles.box, {flex: 2}]}/>
        <View style={[styles.box, {flex: 1}]}/>
      </View>
    )
  }
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    flexDirection: 'row',
    justifyContent: 'center',
    alignItems: 'center',
  },
  box: {
    width: 50,
    height: 50,
    backgroundColor: '#e76e63',
    margin: 10,
  }
});

export default FlexboxExamples;

// ABOVE ADD alignSelf - here drop middle box out of the positioning it inherited from parent and 
  // - alignSelf: flex-end to the second child element
  // - that override  parent instruction (alignItems: 'center')





/* 4. Layout in React Native
    - Native implements Flexbox
    - this default means some diffs
      1) display: flex      don't need to declare this unlike CSS
      2) flex-direction     axes default to column since we're working in mobile
      3) flex: n
        - on web these values set how item scales to manage space around it
        - on mobile these values set how much % children will take up of a parent's flex
 */
// example of using flex values in Native
import React from 'react';
import { View } from 'react-native';

const FlexDemo = props => (
  <View style={{flex: 1}}>
    <View style={{flex: 1, backgroundColor: 'red'}} />
    <View style={{flex: 2, backgroundColor: 'green'}} />
    <View style={{flex: 3, backgroundColor: 'blue'}} />
  </View>
);

export default FlexDemo;
  // here child Views take up chunks of parent View (1 fills whole screen)
  // - blue takes up 3x what red does
  // - green takes up 2x what red does

// other defaults that React Native assigns to components
box-sizing: border-box;
position: relative;
align-items: stretch;
flex-shrink: 0;
align-content: flex-start;
border: 0 solid black;
margin: 0;
padding: 0;
min-width: 0;

/*
  Now let's start styling our project components
 */
// App.js - make this parent View take up all available space in mobile view
...
  <View style={{flex: 1}}>
    <AddEntry />
  </View>
...

// helpers.js - next style the icons for getMetricMetaInfo
import { View, StyleSheet } from 'react-native';
import { white, red, orange, blue, lightPurple, pink } from './colors';

...
const styles = StyleSheet.create({
  iconContainer: {
    padding: 5,
    borderRadius: 8,
    width: 50,
    height: 50,
    justifyContent: 'center',
    alignItem: 'center',
    marginRight: 20
  }
});

// now every View icon style should have this
  getIcon() {
    return (
      <View style={[styles.iconContainer, {backgroundColor: red}]}>
        ...
      </View>
    )
  }
  // but set each background color DIFF'T for running, biking, etc.
  // and change the inner icon color to WHITE

/*
  Platform API
  - users expect their experience to match the platform they're using
  - BUT so far we used iOS icons not Material Design ones
  - access Platform.OS to check
 */
// in App.js
import { Platform } from 'react-native';
...
  <View style={styles.container}>
    {Platform.OS === 'ios'
      ? <Ionicons name="ios-pizza" size={100} color="red" />
      : <Ionicons name="md-pizza" size={100} color="red" />
    }
  </View>

// AddEntry.js - style it up
...
import { View, TouchableOpacity, Text, Platform, StyleSheet } from 'react-native';
...
import { white } from '../utils/colors';
...
function submitBtn({ onPress }) {
  return (
    <TouchableOpacity
      style={Platform.OS === "iOS" ? styles.iosSubmitBtn : styles.androidSubmitBtn}
      onPress={onPress}>
      <Text style={styles.submitBtnText}>Submit</Text>
    </TouchableOpacity>
  );
}
...
  render () {
    if (this.props.alreadyLogged) {
      return (
        <View style={styles.center}>
          <Ionicons
            name={Platform.OS === 'ios' ? 'ios-happy-outline' : 'md-happy'}
            size={100}
          />
          <Text>You already logged your...</Text>
          <TextButton style={{padding: 10}} onPress={this.reset}>
            Reset
          </TextButton>
        </View>
      );
    }

    return (
      <View style={styles.container}>
        ...
        return (
          <View key={key} style={styles.row}>
            ...
          </View>
        );
        ...
      </View>
    );
  }
...
const styles = StyleSheet.create({
  container: {
    flex: 1,
    padding: 20,
    backgroundColor: white,
  },
  row: {
    flexDirection: 'row',
    flex: 1,
    alignItems: 'center'
  },
  iosSubmitBtn: {
    backgroundColor: purple,
    padding: 10,
    borderRadius: 7,
    height: 45,
    marginLeft: 40,
    marginRight: 40
  },
  androidSubmitBtn: {
    backgroundColor: purple,
    padding: 10,
    paddingLeft: 30,
    paddingRight: 30,
    height: 45,
    borderRadius: 2,
    alignSelf: 'flex-end',
    justifyContent: 'center',
    alignItems: 'center'
  },
  submitBtnText: {
    color: white,
    fontSize: 22,
    textAlign: 'center'
  },
  center: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    marginLeft: 30,
    marginRight: 30
  }
});

// UdacitySteppers.js - style Udacity steppers, noting big diff between iOS and Android versions
import { StyleSheet, Platform } from 'react-native';
import { white, gray, purple } from '../utils/colors';
...
    <View style={[styles.row, {justifyContent: 'space-between'}]}>
      {Platform.OS === 'ios'
        ? <View style={{flexDirection: 'row'}}>
            <TouchableOpacity
              style={[styles.iosBtn, {borderTopRightRadius: 0, borderBottomRightRadius: 0}]}
            ...>
              <Entypo name="minus" size={30} color={purple} />
            </TouchableOpacity>
            <TouchableOpacity
              style={[styles.iosBtn, {borderTopLeftRadius: 0, borderBottomLeftRadius: 0}]}
            ...>
              <Entypo name="plus" size={30} color={purple} />
            </TouchableOpacity>
          </View>
        : <View style={{flexDirection: 'row'}}>
            <TouchableOpacity
              style={[styles.androidBtn, {borderTopRightRadius: 0, borderBottomRightRadius: 0}]}
            ...>
              <FontAwesome name="minus" size={30} color={white} />
            </TouchableOpacity>
            <TouchableOpacity
              style={[styles.androidBtn, {borderTopLeftRadius: 0, borderBottomLeftRadius: 0}]}
            ...>
              <FontAwesome name="plus" size={30} color={white} />
            </TouchableOpacity>
          </View>
      }
      <View styles={styles.metricCounter}>
        <Text style={{fontSize: 24, textAlign: 'center'}}>{value}</Text>
        <Text style={{fontSize: 18, color: gray}}>{unit}</Text>
      </View>
    </View>
  )
}

const styles = StyleSheet.create({
  row: {
    flexDirection: 'row',
    flex: 1,
    alignItems: 'center'
  },
  iosBtn: {
    backgroundColor: white,
    borderColor: purple,
    borderWidth: 1,
    borderRadius: 3,
    padding: 25,
    paddingRight: 25
  },
  androidBtn: {
    margin: 5,
    backgroundColor: purple,
    padding: 10,
    borderRadius: 2
  },
  metricCounter: {
    width: 85,
    justifyContent: 'center',
    alignItems: 'center'
  }
});
