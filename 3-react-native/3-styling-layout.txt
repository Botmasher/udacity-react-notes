/*	Lesson 3: Styling and Layout
		
	1. Introduction
 */



/* 2. CSS in JS
	- React separates concerns at a component level, NOT a technology level
	- What are the two things a component's for?
		1) state - component state
		2) presentation - JSX
	- Presentation is more than just markup, it's also STYLES!
	- React Native default pattern and a common pattern: just use JS
 */

// example of applying styles inline to component through React JSX
function Avatar ({ src }) {
  return (
    <View>
      <Image
        style={{borderRadius: 5, margin: 10, width: 48, height: 48}}
        source={{uri: 'https://exmpl.com/happy_glasses-300.png'}}
      />
    </View>
  );
}

// Problems c these JS objects passed to style
	// - clearly above things can get messy fast (like c a big obj)
	// - so you might DRY your code and store the obj separately
const styles = {
  image: {
    borderRadius: 5,
    margin: 10,
    width: 48,
    height: 48
  }
};

function Avatar ({ src }) {
  return (
    <View>
      <Image
        style={styles.image}
        source={{uri: 'https://exmpl.com/happy_glasses-300.png'}}
      />
    </View>
  );
}

// BUT React Native's StyleSheet API goes even further
 /* Benefits:
 		- define multiple styles in one place
		- move styles away from render function
		- named styles add meaning to low-level components in render function
		- can refer to style object id instead of creating a new stylesheet every time
		- send style only once through the bridge
			- subsequent uses are going to refer to an id
		- compile-time validation of your style objects c errors in the console instead of at runtime
 	*/
import React from 'react';
import { StyleSheet, Text, View } from 'react-native';

export default class TextExample extends React.Component {
  render() {
    return (
      <View>
        <Text style={styles.greenLarge}>This is large green text!</Text>
        <Text style={styles.red}>This is smaller red text!</Text>
      </View>
    );
  }
}

const styles = StyleSheet.create({
  greenLarge: {
    color: 'green',
    fontWeight: 'bold',
    fontSize: 40
  },
  red: {
    color: 'red',
    padding: 30
  },
});

// additional styles can be added as array through styles prop
	// - inherits styles so any last styles will take precedence
<Text style={[styles.red, styles.greenLarge]}>Red text but no wait then actually greenLarge text.</Text>

// libraries include Glamorous and Styled Components, both seeing styles as a primary concern of the component





/* 3. Flexbox Guide
  - whenever approaching new tech, instructor asks, "why does this exist?"
  - Flexbox aims to allow dynamic layouts
    - styling elements even when the size is unknown or changing
    - to accomplish this it moves concern from children to immediate parent
    - e.g. instead of float left each child, tell parent that immed children in row and have space btwn
  - Flexible vs Box Model
    - no use of float
    - flexible across screens and devices

  - most important concept is AXES
    - main axis (default vert)
    - cross axis (default horiz)
    - all else is about deciding how to position, scale, center, wrap elements along those two axes

  - flexDirection
    - by default every element has flexDirection: column  
    - can change to flexDirection: row
    - row switches the axes to main horiz and cross vert

  - Justify Content
    - how children align themselves to a component starting along the Main axis
      - justifyContent: flex-start
      - justifyContent: center
      - justifyContent: flex-end
      - justifyContent: space-around
        - puts even vert space btwn each element but aligns top and bottom elements flush
      - justifyContent: space-between
        - puts even vert space around each element including above/below top/bottom elements
 */

// but what if we flipped axes?
container: {
  flex: 1,
  flexDirection: 'row',
  justifyContent: 'space-around',
}
  // now justified along horiz Main axis c space around each element incl L/R of first/last element!

/* 
  Align Items: the Cross Axis
  - alignItems does NOT have the same values as justifyContent
  - you use different values to order how children align along cross axis
    - flex-start  puts children horizontally left (top if you flip flex-direction: row)
    - center      puts children horizontally centered (vertically centered if you flip flex-direction: row)
    - flex-end    puts children horizontally right (bottom if you flip flex-direction: row)
    - stretch     takes up whole row (column if you flip flex-direction: row)

  - note that FlexBox for Native does NOT do percentages!
  - BUT everything you can do c rel percents on web you can still do here
  - flex: 1 will behave like flex-grow does on web (if you're familiar)
 */

// Flex property - here assign one sibling to 2 so that middle one's twice as large as siblings
// End up with:     BOX | B O X | BOX
class FlexboxExamples extends Component {
  render() {
    return (
      <View style={styles.container}>
        <View style={[styles.box, {flex: 1}]}/>
        <View style={[styles.box, {flex: 2}]}/>
        <View style={[styles.box, {flex: 1}]}/>
      </View>
    )
  }
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    flexDirection: 'row',
    justifyContent: 'center',
    alignItems: 'center',
  },
  box: {
    width: 50,
    height: 50,
    backgroundColor: '#e76e63',
    margin: 10,
  }
});

export default FlexboxExamples;

// ABOVE ADD alignSelf - here drop middle box out of the positioning it inherited from parent and 
  // - alignSelf: flex-end to the second child element
  // - that override  parent instruction (alignItems: 'center')





/* 4. Layout in React Native

 */